//U P2

//; SEGMENTS
//T S293d8fdbaa47 _lib_segment_div noload=0 abs=0
//T S8e7b3d203072 _lib_segment_rand noload=0 abs=0
//T Sbe1a78b9d15e _lib_segment_str_chr noload=0 abs=0
//T S0e483de54bb5 _lib_segment_regs_of_gpio noload=0 abs=0
//T S33927ab86900 _lib_segment_regs_of_uart noload=0 abs=0
//T S602f0726a14b _lib_segment_character_fn noload=0 abs=0
//T S847a5c4e618b _lib_segment_isdigit noload=0 abs=0
//T S9a7f1c151839 _lib_segment_islower noload=0 abs=0
//T S154e11ca77b1 _lib_segment_isupper noload=0 abs=0
//T Sf1f3b6b1f10a _lib_segment_isalpha noload=0 abs=0
//T Sb95a2b17779b _lib_segment_isalnum noload=0 abs=0
//T S503b4c87a8c4 _lib_segment_putchar noload=0 abs=0
//T S23554af9f140 _lib_segment_eprints noload=0 abs=0
//T Sb401aee44acb _lib_segment_eprintf noload=0 abs=0
//T Sedd6b6695436 _lib_segment_input_avail noload=0 abs=0
//T S84a19e8ae015 _lib_segment_read noload=0 abs=0
//T Sd14c348df59b _lib_segment_pmon noload=0 abs=0
//T S45ec84dfaab0 _lib_segment_nr_to_mask noload=0 abs=0
//T S38738b71c88c _lib_segment_edge noload=0 abs=0
//T Saed5ad4c4c92 _lib_segment_btn noload=0 abs=0

//; SYMBOLS
//S DR DR 0000ff40 - _
//S CTRL CTRL 0000ff41 - _
//S RSTAT RSTAT 0000ff42 - _
//S TSTAT TSTAT 0000ff43 - _
//S CPB CPB 0000ff44 - _
//S QUEUE QUEUE 0000ff45 - _
//S IRA IRA 0000ff46 - _
//S CHARCNT CHARCNT 0000ff47 - _
//S FIFOCNT FIFOCNT 0000ff48 - _
//S FULLCNT FULLCNT 0000ff49 - _
//S PORTA PORTA 0000ff00 - _
//S DSP DSP 0000ff00 - _
//S PORTB PORTB 0000ff01 - _
//S LED LED 0000ff01 - _
//S PORTC PORTC 0000ff02 - _
//S PORTD PORTD 0000ff03 - _
//S sw sw 0000ff10 - _
//S btn btn 0000ff20 - _
//= check_uart check_uart 0000f008 - _
//= pes pes 0000f012 - _
//L log_ptr log_ptr 00000003 - _
//L real_start real_start 00000004 - _
//L start start 0000001c - _
//L main_cyc main_cyc 0000001c - _
//L nochar nochar 0000002e - _
//L nopress4 nopress4 00000035 - _
//L got_char got_char 00000039 - _
//L echo echo 00000042 - _
//L not_eol not_eol 00000047 - _
//L echo_it echo_it 00000047 - _
//L end end 00000049 - _
//L half_bit_delay half_bit_delay 0000004a - _
//L fake_cyc fake_cyc 0000004e - _
//L wait_tx wait_tx 00000051 - _
//L wait_cyc wait_cyc 00000051 - _
//L send send 00000055 - _
//L send_cyc send_cyc 00000058 - _
//L tx_first_ready tx_first_ready 0000005c - _
//L tx_send tx_send 0000005c - _
//L check_input check_input 0000005e - _
//L qfull qfull 00000062 - _
//L log_ov log_ov 0000006a - _
//L stack stack 000000cf - _
//L logs logs 000000d0 - _
//L div div 000000d1 S293d8fdbaa47 _
//L S293d8fdbaa47div_dok div_dok 000000d8 s S293d8fdbaa47
//L S293d8fdbaa47div_dummy div_dummy 000000d8 s S293d8fdbaa47
//L S293d8fdbaa47div_cyc div_cyc 000000dc s S293d8fdbaa47
//L S293d8fdbaa47div_cyc_next div_cyc_next 000000e7 s S293d8fdbaa47
//L S293d8fdbaa47div_ret div_ret 000000e9 s S293d8fdbaa47
//L S8e7b3d203072seed seed 000000eb s S8e7b3d203072
//L srand srand 000000ec S8e7b3d203072 _
//L rand rand 000000ee S8e7b3d203072 _
//L S8e7b3d203072c1 c1 000000f4 s S8e7b3d203072
//L S8e7b3d203072c2 c2 000000fa s S8e7b3d203072
//L S8e7b3d203072c3 c3 00000100 s S8e7b3d203072
//L str_chr str_chr 00000109 Sbe1a78b9d15e _
//= GPIO.PORTA GPIO.PORTA 0000ff00 S0e483de54bb5 _
//= GPIO.PORTB GPIO.PORTB 0000ff01 S0e483de54bb5 _
//= GPIO.PORTC GPIO.PORTC 0000ff02 S0e483de54bb5 _
//= GPIO.PORTD GPIO.PORTD 0000ff03 S0e483de54bb5 _
//= GPIOA.ODR GPIOA.ODR 0000ff00 S0e483de54bb5 _
//= GPIOB.ODR GPIOB.ODR 0000ff01 S0e483de54bb5 _
//= GPIOC.ODR GPIOC.ODR 0000ff02 S0e483de54bb5 _
//= GPIOD.ODR GPIOD.ODR 0000ff03 S0e483de54bb5 _
//= GPIO.7SEG GPIO.7SEG 0000ff00 S0e483de54bb5 _
//= GPIO.LED GPIO.LED 0000ff01 S0e483de54bb5 _
//= GPIO.PORTI GPIO.PORTI 0000ff20 S0e483de54bb5 _
//= GPIO.PORTJ GPIO.PORTJ 0000ff10 S0e483de54bb5 _
//= GPIOI.IDR GPIOI.IDR 0000ff20 S0e483de54bb5 _
//= GPIOJ.IDR GPIOJ.IDR 0000ff10 S0e483de54bb5 _
//= GPIO.BTN GPIO.BTN 0000ff20 S0e483de54bb5 _
//= GPIO.SW GPIO.SW 0000ff10 S0e483de54bb5 _
//= UART.DR UART.DR 0000ff40 S33927ab86900 _
//= UART.CTRL UART.CTRL 0000ff41 S33927ab86900 _
//= UART.RSTAT UART.RSTAT 0000ff42 S33927ab86900 _
//= UART.TSTAT UART.TSTAT 0000ff43 S33927ab86900 _
//= UART.CPB UART.CPB 0000ff44 S33927ab86900 _
//= UART.SREG0 UART.SREG0 0000ff4c S33927ab86900 _
//= UART.SREG1 UART.SREG1 0000ff4d S33927ab86900 _
//= UART.SREG2 UART.SREG2 0000ff4e S33927ab86900 _
//= UART.SREG3 UART.SREG3 0000ff4f S33927ab86900 _
//L _char_is_true _char_is_true 00000119 S602f0726a14b _
//L _char_is_false _char_is_false 0000011b S602f0726a14b _
//L isdigit isdigit 0000011d S847a5c4e618b _
//L islower islower 00000122 S9a7f1c151839 _
//L isupper isupper 00000127 S154e11ca77b1 _
//L isalpha isalpha 0000012c Sf1f3b6b1f10a _
//L isalnum isalnum 00000131 Sb95a2b17779b _
//L putchar putchar 00000136 S503b4c87a8c4 _
//L eprints eprints 00000137 S23554af9f140 _
//L eprintf eprintf 00000138 Sb401aee44acb _
//L input_avail input_avail 00000139 Sedd6b6695436 _
//L read read 0000013a S84a19e8ae015 _
//= _pm_callin _pm_callin 0000f000 Sd14c348df59b _
//= _pm_enter_by_uart _pm_enter_by_uart 0000f001 Sd14c348df59b _
//= _pm_getchar _pm_getchar 0000f002 Sd14c348df59b _
//= _pm_version _pm_version 0000f003 Sd14c348df59b _
//= _pm_itobcd _pm_itobcd 0000f004 Sd14c348df59b _
//= _pm_cold_start _pm_cold_start 0000f005 Sd14c348df59b _
//= _pm_strchr _pm_strchr 0000f006 Sd14c348df59b _
//= _pm_streq _pm_streq 0000f007 Sd14c348df59b _
//= _pm_check_uart _pm_check_uart 0000f008 Sd14c348df59b _
//= _pm_input_avail _pm_input_avail 0000f008 Sd14c348df59b _
//= _pm_hexchar2value _pm_hexchar2value 0000f009 Sd14c348df59b _
//= _pm_value2hexchar _pm_value2hexchar 0000f00a Sd14c348df59b _
//= _pm_htoi _pm_htoi 0000f00b Sd14c348df59b _
//= _pm_strieq _pm_strieq 0000f00c Sd14c348df59b _
//= _pm_read _pm_read 0000f00d Sd14c348df59b _
//= _pm_putchar _pm_putchar 0000f00e Sd14c348df59b _
//= _pm_prints _pm_prints 0000f00f Sd14c348df59b _
//= _pm_printsnl _pm_printsnl 0000f010 Sd14c348df59b _
//= _pm_print_vhex _pm_print_vhex 0000f011 Sd14c348df59b _
//= _pm_pes _pm_pes 0000f012 Sd14c348df59b _
//= _pm_printd _pm_printd 0000f013 Sd14c348df59b _
//= _pm_printf _pm_printf 0000f014 Sd14c348df59b _
//= _pm_pesf _pm_pesf 0000f015 Sd14c348df59b _
//= _pm_ascii2seg _pm_ascii2seg 0000f016 Sd14c348df59b _
//L monitor monitor 0000013c Sd14c348df59b _
//L monitor_by_uart monitor_by_uart 0000013d Sd14c348df59b _
//L monitor_by_button monitor_by_button 0000013e Sd14c348df59b _
//L monitor_version monitor_version 00000144 Sd14c348df59b _
//L _nr_to_mask _nr_to_mask 0000014a S45ec84dfaab0 _
//L S45ec84dfaab0nr_to_mask_cyc nr_to_mask_cyc 0000014d s S45ec84dfaab0
//L S45ec84dfaab0nr_to_mask_ret nr_to_mask_ret 00000152 s S45ec84dfaab0
//L S38738b71c88clast_btn last_btn 00000155 s S38738b71c88c
//L S38738b71c88clast_sw last_sw 00000156 s S38738b71c88c
//L S38738b71c88clast_btn_down last_btn_down 00000157 s S38738b71c88c
//L S38738b71c88clast_sw_down last_sw_down 00000158 s S38738b71c88c
//L S38738b71c88clast_btn_inited last_btn_inited 00000159 s S38738b71c88c
//L S38738b71c88clast_sw_inited last_sw_inited 0000015a s S38738b71c88c
//L _lib_edge_detect _lib_edge_detect 0000015b S38738b71c88c _
//L S38738b71c88cinit_btn init_btn 00000163 s S38738b71c88c
//L S38738b71c88cinit_sw init_sw 0000016c s S38738b71c88c
//L S38738b71c88cpressed_inited pressed_inited 00000175 s S38738b71c88c
//L S38738b71c88cch_btn ch_btn 00000178 s S38738b71c88c
//L S38738b71c88cch_sw ch_sw 0000017b s S38738b71c88c
//L S38738b71c88ccheck_push check_push 0000018b s S38738b71c88c
//L S38738b71c88ccheck_release check_release 0000018e s S38738b71c88c
//L S38738b71c88cpressed_true pressed_true 00000190 s S38738b71c88c
//L S38738b71c88cpressed_false pressed_false 00000192 s S38738b71c88c
//L S38738b71c88cpressed_end pressed_end 00000193 s S38738b71c88c
//L btn_restart btn_restart 00000199 S38738b71c88c _
//L sw_restart sw_restart 0000019e S38738b71c88c _
//L btn_posedge btn_posedge 000001a3 Saed5ad4c4c92 _
//L btn_negedge btn_negedge 000001ab Saed5ad4c4c92 _
//L btn_get btn_get 000001b3 Saed5ad4c4c92 _

//; CODE
//P -
//F uart2.asm
00000000 //C 00001    28 nop
01f20004 //C 00002    29 jmp	real_start
//R 00002 #16 real_start 00000004
00000000 //C 00003    30 dd	0
//G log_ptr
01d200cf //C 00004    32 ldl0	sp,stack
//R 00004 #16 stack 000000cf
//G real_start
f400f012 //C 00005    34 ces	pes
//R 00005 #24 pes 0000f012
00000048 //C 00006    35 db	72
00000065 //C 00007    35 db	101
0000006c //C 00008    35 db	108
0000006c //C 00009    35 db	108
0000006f //C 0000a    35 db	111
00000020 //C 0000b    35 db	32
00000057 //C 0000c    35 db	87
0000006f //C 0000d    35 db	111
00000072 //C 0000e    35 db	114
0000006c //C 0000f    35 db	108
00000064 //C 00010    35 db	100
0000000a //C 00011    35 db	10
00000000 //C 00012    35 db
07000000 //C 00013    37 ld	r0,0
0600ff00 //C 00014    38 st	r0,PORTA
//R 00014 #16 PORTA 0000ff00
0600ff01 //C 00015    39 st	r0,PORTB
//R 00015 #16 PORTB 0000ff01
0600ff02 //C 00016    40 st	r0,PORTC
//R 00016 #16 PORTC 0000ff02
0600ff03 //C 00017    41 st	r0,PORTD
//R 00017 #16 PORTD 0000ff03
01020003 //C 00018    45 mvzl	r0,0x3		; enable rx, tx
0600ff41 //C 00019    46 st	r0,CTRL
//R 00019 #16 CTRL 0000ff41
0102003e //C 0001a    48 mvzl	r0,'>'		; send prompt
0600ff40 //C 0001b    49 st	r0,DR
//R 0001b #16 DR 0000ff40
0740ff42 //C 0001c    54 ld	r4,RSTAT	; checkin: read RSTAT
//R 0001c #16 RSTAT 0000ff42
//G start
//G main_cyc
014c0020 //C 0001d    56 test	r4,0x20		; check if queue is full
24000062 //C 0001e    57 NZ call	qfull
//R 0001e #24 qfull 00000062
2640ff00 //C 0001f    58 NZ st	r4,PORTA	; display RSTAT, if queue is full
//R 0001f #16 PORTA 0000ff00
014c0001 //C 00020    60 test	r4,1		; Z=0 Received avail
24000039 //C 00021    61 NZ call	got_char	; avail: jump to handle
//R 00021 #24 got_char 00000039
01020001 //C 00022    65 ldl0	r0,1		; check btn[1]
040001a3 //C 00023    66 call	btn_posedge
//R 00023 #24 btn_posedge 000001a3
3400f000 //C 00024    68 C call	0xf000		; enter monitor
0790ff49 //C 00025    70 ld	r9,FULLCNT
//R 00025 #16 FULLCNT 0000ff49
0690ff03 //C 00026    71 st	r9,PORTD
//R 00026 #16 PORTD 0000ff03
07a0ff48 //C 00027    72 ld	r10,FIFOCNT
//R 00027 #16 FIFOCNT 0000ff48
06a0ff02 //C 00028    73 st	r10,PORTC
//R 00028 #16 PORTC 0000ff02
01f2001c //C 00029    75 jmp	main_cyc
//R 00029 #16 main_cyc 0000001c
0400f008 //C 0002a    78 call	check_uart
//R 0002a #24 check_uart 0000f008
41f2002e //C 0002b    79 NC jmp	nochar
//R 0002b #16 nochar 0000002e
0400013a //C 0002c    80 call	read
//R 0002c #24 read 0000013a
04000055 //C 0002d    81 call	send
//R 0002d #24 send 00000055
01020002 //C 0002e    83 ldl0	r0,2
//G nochar
040001a3 //C 0002f    84 call	btn_posedge
//R 0002f #24 btn_posedge 000001a3
41f20035 //C 00030    85 NC jmp	nopress4
//R 00030 #16 nopress4 00000035
0400005e //C 00031    87 call	check_input
//R 00031 #24 check_input 0000005e
11f20035 //C 00032    88 jz	nopress4
//R 00032 #16 nopress4 00000035
0700ff45 //C 00033    89 ld	r0,QUEUE
//R 00033 #16 QUEUE 0000ff45
01f20039 //C 00034    90 jmp	got_char
//R 00034 #16 got_char 00000039
0400005e //C 00035    92 call	check_input
//R 00035 #24 check_input 0000005e
//G nopress4
2700ff40 //C 00036    93 NZ ld	r0,DR
//R 00036 #16 DR 0000ff40
21f20039 //C 00037    94 jnz	got_char
//R 00037 #16 got_char 00000039
01f2001c //C 00038    95 jmp	main_cyc
//R 00038 #16 main_cyc 0000001c
0ded0000 //C 00039    99 push	lr
//G got_char
0700ff40 //C 0003a   100 ld	r0,DR		; avail: read UART DR
//R 0003a #16 DR 0000ff40
0400004a //C 0003b   102 call	half_bit_delay
//R 0003b #24 half_bit_delay 0000004a
0600ff46 //C 0003c   104 st	r0,IRA		; inc raddr counter in fifo
//R 0003c #16 IRA 0000ff46
0710ff01 //C 0003d   106 ld	r1,PORTB
//R 0003d #16 PORTB 0000ff01
01140001 //C 0003e   107 add	r1,1
0610ff01 //C 0003f   108 st	r1,PORTB
//R 0003f #16 PORTB 0000ff01
04000042 //C 00040   110 call	echo
//R 00040 #24 echo 00000042
0ffd0000 //C 00041   111 pop	pc
0ded0000 //C 00042   116 push	lr
//G echo
0108000a //C 00043   117 cmp	r0,10
11f20047 //C 00044   118 jz	echo_it
//R 00044 #16 echo_it 00000047
0108000d //C 00045   119 cmp	r0,13
11f20047 //C 00046   120 jz	echo_it
//R 00046 #16 echo_it 00000047
04000055 //C 00047   127 call	send
//R 00047 #24 send 00000055
//G not_eol
//G echo_it
0ffd0000 //C 00048   128 pop	pc
01f2001c //C 00049   132 end:	jmp	start
//R 00049 #16 start 0000001c
//G end
0780ff10 //C 0004a   137 ld	r8,sw
//R 0004a #16 sw 0000ff10
//G half_bit_delay
018b00ff //C 0004b   138 btst	r8,255
028b0000 //C 0004c   139 sz	r8
10f00e00 //C 0004d   140 Z ret
0184ffff //C 0004e   142 dec	r8
//G fake_cyc
21f2004e //C 0004f   143 jnz	fake_cyc
//R 0004f #16 fake_cyc 0000004e
00f00e00 //C 00050   144 ret
0730ff43 //C 00051   149 ld	r3,TSTAT	; read TSTAT
//R 00051 #16 TSTAT 0000ff43
//G wait_tx
//G wait_cyc
013c0001 //C 00052   150 test	r3,1		; check TC bit
11f20051 //C 00053   151 Z jmp	wait_cyc	; wait tx cycle
//R 00053 #16 wait_cyc 00000051
00f00e00 //C 00054   152 ret
0730ff43 //C 00055   157 ld	r3,TSTAT
//R 00055 #16 TSTAT 0000ff43
//G send
013c0001 //C 00056   158 test	r3,1
21f2005c //C 00057   159 jnz	tx_first_ready
//R 00057 #16 tx_first_ready 0000005c
0730ff43 //C 00058   161 ld	r3,TSTAT
//R 00058 #16 TSTAT 0000ff43
//G send_cyc
013c0001 //C 00059   162 test	r3,1
11f20058 //C 0005a   163 jz	send_cyc
//R 0005a #16 send_cyc 00000058
21f2005c //C 0005b   164 jnz	tx_send
//R 0005b #16 tx_send 0000005c
0600ff40 //C 0005c   170 st	r0,DR		; put R0 in uart DR
//R 0005c #16 DR 0000ff40
//G tx_first_ready
//G tx_send
00f00e00 //C 0005d   172 ret
0740ff42 //C 0005e   176 ld	r4,RSTAT	; checkin: read RSTAT
//R 0005e #16 RSTAT 0000ff42
//G check_input
0640ff00 //C 0005f   177 st	r4,DSP		; display RSTAT
//R 0005f #16 DSP 0000ff00
014c0001 //C 00060   178 test	r4,1		; Z=0 Received avail
00f00e00 //C 00061   180 ret
0ded0000 //C 00062   185 push	lr
//G qfull
07500003 //C 00063   186 ld	r5,log_ptr
//R 00063 #16 log_ptr 00000003
01628000 //C 00064   187 mvzl	r6,0x8000
00580600 //C 00065   188 cmp	r5,r6
31f2006a //C 00066   189 CS jmp	log_ov
//R 00066 #16 log_ov 0000006a
0c4500d0 //C 00067   190 st	r4,r5,logs
//R 00067 #16 logs 000000d0
01540001 //C 00068   191 inc	r5
06500003 //C 00069   192 st	r5,log_ptr
//R 00069 #16 log_ptr 00000003
0ffd0000 //C 0006a   194 pop	pc
//G log_ov
00000000 //C 0006b   198 ds	100
//+ 00000064
00000000 //C 000cf   200 db	0
//G stack
0ded0000 //C 000d0    12 push	lr
//G logs
//F math.asm
//P S293d8fdbaa47 _lib_segment_div
0ded0000 //C 000d1    15 push	lr
//G div
0d6d0000 //C 000d2    16 push	r6
021b0000 //C 000d3    18 sz	r1
21f200d8 //C 000d4    19 NZ jmp	div_dok
//R 000d4 #16 div_dok 000000d8
00400000 //C 000d5    20 mov	r4,r0		; div by zero
01520000 //C 000d6    21 mvzl	r5,0x0
01f200e9 //C 000d7    22 jmp	div_ret
//R 000d7 #16 div_ret 000000e9
01420000 //C 000d8    25 mvzl	r4,0		; Q= 0
//N div_dok S293d8fdbaa47
//N div_dummy S293d8fdbaa47
01520000 //C 000d9    26 mvzl	r5,0		; R= 0
01618000 //C 000da    27 mvh	r6,0x80000000	; m= 1<<31
01600000 //C 000db    28 mvl	r6,0x80000000
026b0000 //C 000dc    30 sz	r6
//N div_cyc S293d8fdbaa47
11f200e9 //C 000dd    31 Z jmp	div_ret
//R 000dd #16 div_ret 000000e9
02580000 //C 000de    32 shl	r5		; r<<= 1
000c0600 //C 000df    33 test	r0,r6		; if (n&m)
215d0001 //C 000e0    34 NZ or	r5,1		; r|= 1
00580100 //C 000e1    35 cmp	r5,r1		; if (r>=d)
41f200e7 //C 000e2    36 LO jmp	div_cyc_next
//R 000e2 #16 div_cyc_next 000000e7
00560100 //C 000e3    37 sub	r5,r1		; r-= d
004d0600 //C 000e4    38 or	r4,r6		; q|= m
01f200e7 //C 000e5    39 jmp	div_cyc_next
//R 000e5 #16 div_cyc_next 000000e7
01f200dc //C 000e6    40 jmp	div_cyc
//R 000e6 #16 div_cyc 000000dc
02690000 //C 000e7    42 shr	r6		; m>>= 1
//N div_cyc_next S293d8fdbaa47
01f200dc //C 000e8    43 jmp	div_cyc
//R 000e8 #16 div_cyc 000000dc
0f6d0000 //C 000e9    45 pop	r6
//N div_ret S293d8fdbaa47
0ffd0000 //C 000ea    46 pop	pc
//P S8e7b3d203072 _lib_segment_rand
00000049 //C 000eb    58 db	2127401289
//N seed S8e7b3d203072
060000eb //C 000ec    65 st	r0,seed
//R 000ec #16 seed 000000eb
//G srand
00f00e00 //C 000ed    66 ret
0ded0000 //C 000ee    72 push	lr
//G rand
0d0d0000 //C 000ef    73 push	r0
0d2d0000 //C 000f0    74 push	r2
070000eb //C 000f1    76 ld	r0,seed
//R 000f1 #16 seed 000000eb
00400000 //C 000f2    77 mov	r4,r0
0122000d //C 000f3    78 mvzl	r2,13
02480000 //C 000f4    79 c1:	shl	r4
//N c1 S8e7b3d203072
0124ffff //C 000f5    80 dec	r2
21f200f4 //C 000f6    81 jnz	c1
//R 000f6 #16 c1 000000f4
000e0400 //C 000f7    82 xor	r0,r4
00400000 //C 000f8    83 mov	r4,r0
01220011 //C 000f9    84 mvzl	r2,17
02490000 //C 000fa    85 c2:	shr	r4
//N c2 S8e7b3d203072
0124ffff //C 000fb    86 dec	r2
21f200fa //C 000fc    87 jnz	c2
//R 000fc #16 c2 000000fa
000e0400 //C 000fd    88 xor	r0,r4
00400000 //C 000fe    89 mov	r4,r0
01220005 //C 000ff    90 mvzl	r2,5
02480000 //C 00100    91 c3:	shl	r4
//N c3 S8e7b3d203072
0124ffff //C 00101    92 dec	r2
21f20100 //C 00102    93 jnz	c3
//R 00102 #16 c3 00000100
000e0400 //C 00103    94 xor	r0,r4
060000eb //C 00104    95 st	r0,seed
//R 00104 #16 seed 000000eb
00400000 //C 00105    97 mov	r4,r0
0f2d0000 //C 00106    99 pop	r2
0f0d0000 //C 00107   100 pop	r0
0ffd0000 //C 00108   101 pop	pc
//F str.asm
//P Sbe1a78b9d15e _lib_segment_str_chr
020b0000 //C 00109    94 sz	r0		; check NULL pointer
//G str_chr
120d0000 //C 0010a    95 Z clc
10f00e00 //C 0010b    96 Z ret
02100000 //C 0010c    97 zeb	r1		; prepare character
0ded0000 //C 0010d    98 push	lr
0d1d0000 //C 0010e    99 push	r1
0d2d0000 //C 0010f   100 push	r2
00400000 //C 00110   101 mov	r4,r0
00000100 //C 00111   102 mov	r0,r1
00100400 //C 00112   103 mov	r1,r4
0400f006 //C 00113   104 call	_pm_strchr
//R 00113 #24 _pm_strchr 0000f006
00400100 //C 00114   105 mov	r4,r1
00500200 //C 00115   106 mov	r5,r2
0f2d0000 //C 00116   107 pop	r2
0f1d0000 //C 00117   108 pop	r1
0ffd0000 //C 00118   109 pop	pc
//F char.asm
//P S602f0726a14b _lib_segment_character_fn
020c0000 //C 00119    22 sec
//G _char_is_true
00f00e00 //C 0011a    23 ret
020d0000 //C 0011b    25 clc
//G _char_is_false
00f00e00 //C 0011c    26 ret
//P S847a5c4e618b _lib_segment_isdigit
01080030 //C 0011d    37 cmp	R0,'0'
//G isdigit
41f2011b //C 0011e    38 ULT jmp	_char_is_false
//R 0011e #16 _char_is_false 0000011b
01080039 //C 0011f    39 cmp	R0,'9'
91f2011b //C 00120    40 UGT jmp	_char_is_false
//R 00120 #16 _char_is_false 0000011b
01f20119 //C 00121    41 jmp _char_is_true
//R 00121 #16 _char_is_true 00000119
//P S9a7f1c151839 _lib_segment_islower
01080061 //C 00122    53 cmp	r0,'a'
//G islower
41f2011b //C 00123    54 ULT jmp	_char_is_false
//R 00123 #16 _char_is_false 0000011b
0108007a //C 00124    55 cmp	r0,'z'
91f2011b //C 00125    56 UGT jmp	_char_is_false
//R 00125 #16 _char_is_false 0000011b
01f20119 //C 00126    57 jmp	_char_is_true
//R 00126 #16 _char_is_true 00000119
//P S154e11ca77b1 _lib_segment_isupper
01080041 //C 00127    69 cmp	r0,'A'
//G isupper
41f2011b //C 00128    70 ULT jmp	_char_is_false
//R 00128 #16 _char_is_false 0000011b
0108005a //C 00129    71 cmp	r0,'Z'
91f2011b //C 0012a    72 UGT jmp	_char_is_false
//R 0012a #16 _char_is_false 0000011b
01f20119 //C 0012b    73 jmp	_char_is_true
//R 0012b #16 _char_is_true 00000119
//P Sf1f3b6b1f10a _lib_segment_isalpha
0ded0000 //C 0012c    85 push	lr
//G isalpha
04000122 //C 0012d    86 call	islower
//R 0012d #24 islower 00000122
3ffd0000 //C 0012e    87 C pop	pc
04000127 //C 0012f    88 call	isupper
//R 0012f #24 isupper 00000127
0ffd0000 //C 00130    89 pop	pc
//P Sb95a2b17779b _lib_segment_isalnum
0ded0000 //C 00131   101 push	lr
//G isalnum
0400012c //C 00132   102 call	isalpha
//R 00132 #24 isalpha 0000012c
3ffd0000 //C 00133   103 C pop	pc
0400011d //C 00134   104 call	isdigit
//R 00134 #24 isdigit 0000011d
0ffd0000 //C 00135   105 pop	pc
//F inout.asm
//P S503b4c87a8c4 _lib_segment_putchar
01f2f00e //C 00136    24 jmp	_pm_putchar
//R 00136 #16 _pm_putchar 0000f00e
//G putchar
//P S23554af9f140 _lib_segment_eprints
01f2f012 //C 00137    54 jmp	_pm_pes
//R 00137 #16 _pm_pes 0000f012
//G eprints
//P Sb401aee44acb _lib_segment_eprintf
01f2f015 //C 00138    66 jmp	_pm_pesf
//R 00138 #16 _pm_pesf 0000f015
//G eprintf
//P Sedd6b6695436 _lib_segment_input_avail
01f2f008 //C 00139    72 jmp	_pm_check_uart
//R 00139 #16 _pm_check_uart 0000f008
//G input_avail
//P S84a19e8ae015 _lib_segment_read
0740ff40 //C 0013a    89 ld	r4,UART.DR
//R 0013a #16 UART.DR 0000ff40
//G read
00f00e00 //C 0013b    90 ret
//F mon.asm
//P Sd14c348df59b _lib_segment_pmon
01f2f000 //C 0013c    40 jmp	_pm_callin
//R 0013c #16 _pm_callin 0000f000
//G monitor
01f2f001 //C 0013d    44 jmp	_pm_enter_by_uart
//R 0013d #16 _pm_enter_by_uart 0000f001
//G monitor_by_uart
0ded0000 //C 0013e    48 push	lr
//G monitor_by_button
040001a3 //C 0013f    49 call	btn_posedge
//R 0013f #24 btn_posedge 000001a3
4ffd0000 //C 00140    50 NC pop	pc
0400013c //C 00141    51 call	monitor
//R 00141 #24 monitor 0000013c
04000199 //C 00142    52 call	btn_restart
//R 00142 #24 btn_restart 00000199
0ffd0000 //C 00143    53 pop	pc
0ded0000 //C 00144    57 push	lr
//G monitor_version
0d0d0000 //C 00145    58 push	r0
0400f003 //C 00146    59 call	_pm_version
//R 00146 #24 _pm_version 0000f003
00400000 //C 00147    60 mov	r4,r0
0f0d0000 //C 00148    61 pop	r0
0ffd0000 //C 00149    62 pop	pc
//F bsp.asm
//P S45ec84dfaab0 _lib_segment_nr_to_mask
0d1d0000 //C 0014a    26 push	r1
//G _nr_to_mask
010b001f //C 0014b    27 btst	r0,0x1f		; max nr is 31
01120001 //C 0014c    28 mvzl	r1,1		; mask for nr==0
020b0000 //C 0014d    30 sz	r0		; is nr zero?
//N nr_to_mask_cyc S45ec84dfaab0
11f20152 //C 0014e    31 jz	nr_to_mask_ret	; if yes, go out
//R 0014e #16 nr_to_mask_ret 00000152
02180000 //C 0014f    32 shl	r1		; shift mask up
0104ffff //C 00150    33 dec	r0		; decrement nr
01f2014d //C 00151    34 jmp	nr_to_mask_cyc	; check for zero
//R 00151 #16 nr_to_mask_cyc 0000014d
00000100 //C 00152    36 mov	r0,r1		; return mask in R0
//N nr_to_mask_ret S45ec84dfaab0
0f1d0000 //C 00153    37 pop	r1
00f00e00 //C 00154    38 ret
//P S38738b71c88c _lib_segment_edge
00000000 //C 00155   120 ds	1
//+ 00000001
//N last_btn S38738b71c88c
00000000 //C 00156   122 ds	1
//+ 00000001
//N last_sw S38738b71c88c
00000000 //C 00157   124 ds	1
//+ 00000001
//N last_btn_down S38738b71c88c
00000000 //C 00158   126 ds	1
//+ 00000001
//N last_sw_down S38738b71c88c
00000000 //C 00159   128 db	0
//N last_btn_inited S38738b71c88c
00000000 //C 0015a   130 db	0
//N last_sw_inited S38738b71c88c
0ded0000 //C 0015b   141 push	lr
//G _lib_edge_detect
0d1d0000 //C 0015c   142 push	r1
0d2d0000 //C 0015d   143 push	r2
0d3d0000 //C 0015e   144 push	r3
0d4d0000 //C 0015f   145 push	r4
0d5d0000 //C 00160   146 push	r5
00500100 //C 00161   148 mov	r5,r1		; what edge to check
31f2016c //C 00162   149 C jmp	init_sw
//R 00162 #16 init_sw 0000016c
07100159 //C 00163   151 ld	r1,last_btn_inited
//R 00163 #16 last_btn_inited 00000159
//N init_btn S38738b71c88c
021b0000 //C 00164   152 sz	r1
21f20175 //C 00165   153 jnz	pressed_inited
//R 00165 #16 pressed_inited 00000175
01120001 //C 00166   154 mvzl	r1,1
06100159 //C 00167   155 st	r1,last_btn_inited
//R 00167 #16 last_btn_inited 00000159
0710ff20 //C 00168   156 ld	r1,GPIO.BTN
//R 00168 #16 GPIO.BTN 0000ff20
06100155 //C 00169   157 st	r1,last_btn
//R 00169 #16 last_btn 00000155
06100157 //C 0016a   158 st	r1,last_btn_down
//R 0016a #16 last_btn_down 00000157
01f20192 //C 0016b   159 jmp	pressed_false
//R 0016b #16 pressed_false 00000192
0710015a //C 0016c   161 ld	r1,last_sw_inited
//R 0016c #16 last_sw_inited 0000015a
//N init_sw S38738b71c88c
021b0000 //C 0016d   162 sz	r1
21f20175 //C 0016e   163 jnz	pressed_inited
//R 0016e #16 pressed_inited 00000175
01120001 //C 0016f   164 mvzl	r1,1
0610015a //C 00170   165 st	r1,last_sw_inited
//R 00170 #16 last_sw_inited 0000015a
0710ff10 //C 00171   166 ld	r1,GPIO.SW
//R 00171 #16 GPIO.SW 0000ff10
06100156 //C 00172   167 st	r1,last_sw
//R 00172 #16 last_sw 00000156
06100158 //C 00173   168 st	r1,last_sw_down
//R 00173 #16 last_sw_down 00000158
01f20192 //C 00174   169 jmp	pressed_false
//R 00174 #16 pressed_false 00000192
4122ff20 //C 00175   173 NC mvzl	r2,GPIO.BTN
//R 00175 #16 GPIO.BTN 0000ff20
//N pressed_inited S38738b71c88c
3122ff10 //C 00176   174 C mvzl	r2,GPIO.SW
//R 00176 #16 GPIO.SW 0000ff10
31f2017b //C 00177   175 jc	ch_sw
//R 00177 #16 ch_sw 0000017b
025b0000 //C 00178   177 sz	r5
//N ch_btn S38738b71c88c
11120155 //C 00179   178 Z mvzl	r1,last_btn
//R 00179 #16 last_btn 00000155
21120157 //C 0017a   179 NZ mvzl	r1,last_btn_down
//R 0017a #16 last_btn_down 00000157
025b0000 //C 0017b   181 sz	r5
//N ch_sw S38738b71c88c
11120156 //C 0017c   182 Z mvzl	r1,last_sw
//R 0017c #16 last_sw 00000156
21120158 //C 0017d   183 NZ mvzl	r1,last_sw_down
//R 0017d #16 last_sw_down 00000158
0e310000 //C 0017e   187 ld	r3,r1
0e420000 //C 0017f   188 ld	r4,r2
003f0000 //C 00180   190 and	r3,r0		; masked last
004f0000 //C 00181   191 and	r4,r0		; masked port
00380400 //C 00182   192 cmp	r3,r4
11f20192 //C 00183   193 EQ jmp	pressed_false
//R 00183 #16 pressed_false 00000192
02040000 //C 00184   194 not	r0		; negated mask
0e310000 //C 00185   195 ld	r3,r1		; original last
003f0000 //C 00186   196 and	r3,r0		; clear checked bit
003d0400 //C 00187   197 or	r3,r4		; or with masked port
0c310000 //C 00188   198 st	r3,r1		; store new last value
025b0000 //C 00189   199 sz	r5
21f2018e //C 0018a   200 jnz	check_release
//R 0018a #16 check_release 0000018e
024b0000 //C 0018b   202 sz	r4		; check new port value
//N check_push S38738b71c88c
11f20192 //C 0018c   203 jz	pressed_false
//R 0018c #16 pressed_false 00000192
21f20190 //C 0018d   204 jnz	pressed_true
//R 0018d #16 pressed_true 00000190
024b0000 //C 0018e   206 sz	r4
//N check_release S38738b71c88c
21f20192 //C 0018f   207 jnz	pressed_false
//R 0018f #16 pressed_false 00000192
020c0000 //C 00190   210 sec
//N pressed_true S38738b71c88c
01f20193 //C 00191   211 jmp	pressed_end
//R 00191 #16 pressed_end 00000193
020d0000 //C 00192   213 clc
//N pressed_false S38738b71c88c
0f5d0000 //C 00193   215 pop	r5
//N pressed_end S38738b71c88c
0f4d0000 //C 00194   216 pop	r4
0f3d0000 //C 00195   217 pop	r3
0f2d0000 //C 00196   218 pop	r2
0f1d0000 //C 00197   219 pop	r1
0ffd0000 //C 00198   220 pop	pc
0d1d0000 //C 00199   225 push	r1
//G btn_restart
0710ff20 //C 0019a   226 ld	r1,GPIO.BTN
//R 0019a #16 GPIO.BTN 0000ff20
06100155 //C 0019b   227 st	r1,last_btn
//R 0019b #16 last_btn 00000155
0f1d0000 //C 0019c   228 pop	r1
00f00e00 //C 0019d   229 ret
0d1d0000 //C 0019e   233 push	r1
//G sw_restart
0710ff10 //C 0019f   234 ld	r1,GPIO.SW
//R 0019f #16 GPIO.SW 0000ff10
06100156 //C 001a0   235 st	r1,last_sw
//R 001a0 #16 last_sw 00000156
0f1d0000 //C 001a1   236 pop	r1
00f00e00 //C 001a2   237 ret
//P Saed5ad4c4c92 _lib_segment_btn
0ded0000 //C 001a3   250 push	lr
//G btn_posedge
0400014a //C 001a4   251 call	_nr_to_mask
//R 001a4 #24 _nr_to_mask 0000014a
0d1d0000 //C 001a5   252 push	r1
01120000 //C 001a6   253 mvzl	r1,0
020d0000 //C 001a7   254 clc
0400015b //C 001a8   255 call	_lib_edge_detect
//R 001a8 #24 _lib_edge_detect 0000015b
0f1d0000 //C 001a9   256 pop	r1
0ffd0000 //C 001aa   257 pop	pc
0ded0000 //C 001ab   266 push	lr
//G btn_negedge
0400014a //C 001ac   267 call	_nr_to_mask
//R 001ac #24 _nr_to_mask 0000014a
0d1d0000 //C 001ad   268 push	r1
01120001 //C 001ae   269 mvzl	r1,1
020d0000 //C 001af   270 clc
0400015b //C 001b0   271 call	_lib_edge_detect
//R 001b0 #24 _lib_edge_detect 0000015b
0f1d0000 //C 001b1   272 pop	r1
0ffd0000 //C 001b2   273 pop	pc
0ded0000 //C 001b3   282 push	lr
//G btn_get
0d1d0000 //C 001b4   283 push	r1
0400014a //C 001b5   284 call	_nr_to_mask
//R 001b5 #24 _nr_to_mask 0000014a
0710ff20 //C 001b6   285 ld	r1,GPIO.BTN
//R 001b6 #16 GPIO.BTN 0000ff20
001f0000 //C 001b7   286 and	r1,r0
120d0000 //C 001b8   287 Z clc
220c0000 //C 001b9   288 NZ sec
0f1d0000 //C 001ba   289 pop	r1
0ffd0000 //C 001bb   290 pop	pc
//H 24627e0e
//E
