//U P1

//; SEGMENTS
//T S293d8fdbaa47 _lib_segment_div noload=0 abs=0
//T S8e7b3d203072 _lib_segment_rand noload=0 abs=0
//T Sbe1a78b9d15e _lib_segment_str_chr noload=0 abs=0
//T S0e483de54bb5 _lib_segment_regs_of_gpio noload=0 abs=0
//T S33927ab86900 _lib_segment_regs_of_uart noload=0 abs=0
//T S602f0726a14b _lib_segment_character_fn noload=0 abs=0
//T S847a5c4e618b _lib_segment_isdigit noload=0 abs=0
//T S9a7f1c151839 _lib_segment_islower noload=0 abs=0
//T S154e11ca77b1 _lib_segment_isupper noload=0 abs=0
//T Sf1f3b6b1f10a _lib_segment_isalpha noload=0 abs=0
//T Sb95a2b17779b _lib_segment_isalnum noload=0 abs=0
//T S503b4c87a8c4 _lib_segment_putchar noload=0 abs=0
//T S23554af9f140 _lib_segment_eprints noload=0 abs=0
//T Sb401aee44acb _lib_segment_eprintf noload=0 abs=0
//T Sedd6b6695436 _lib_segment_input_avail noload=0 abs=0
//T S84a19e8ae015 _lib_segment_read noload=0 abs=0
//T Sd14c348df59b _lib_segment_pmon noload=0 abs=0
//T S45ec84dfaab0 _lib_segment_nr_to_mask noload=0 abs=0
//T S38738b71c88c _lib_segment_edge noload=0 abs=0
//T Saed5ad4c4c92 _lib_segment_btn noload=0 abs=0

//; SYMBOLS
//S display display 0000ff00 - _
//S led led 0000ff01 - _
//S btn btn 0000ff20 - _
//S sw sw 0000ff10 - _
//L init init 00000009 - _
//L cycl cycl 0000000c - _
//L changed changed 00000011 - _
//L l_h l_h 00000014 - _
//L nochange nochange 00000019 - _
//L prev prev 0000001e - _
//L cnt cnt 0000001f - _
//L div div 00000020 S293d8fdbaa47 _
//L S293d8fdbaa47div_dok div_dok 00000027 s S293d8fdbaa47
//L S293d8fdbaa47div_dummy div_dummy 00000027 s S293d8fdbaa47
//L S293d8fdbaa47div_cyc div_cyc 0000002b s S293d8fdbaa47
//L S293d8fdbaa47div_cyc_next div_cyc_next 00000036 s S293d8fdbaa47
//L S293d8fdbaa47div_ret div_ret 00000038 s S293d8fdbaa47
//L S8e7b3d203072seed seed 0000003a s S8e7b3d203072
//L srand srand 0000003b S8e7b3d203072 _
//L rand rand 0000003d S8e7b3d203072 _
//L S8e7b3d203072c1 c1 00000043 s S8e7b3d203072
//L S8e7b3d203072c2 c2 00000049 s S8e7b3d203072
//L S8e7b3d203072c3 c3 0000004f s S8e7b3d203072
//L str_chr str_chr 00000058 Sbe1a78b9d15e _
//= GPIO.PORTA GPIO.PORTA 0000ff00 S0e483de54bb5 _
//= GPIO.PORTB GPIO.PORTB 0000ff01 S0e483de54bb5 _
//= GPIO.PORTC GPIO.PORTC 0000ff02 S0e483de54bb5 _
//= GPIO.PORTD GPIO.PORTD 0000ff03 S0e483de54bb5 _
//= GPIOA.ODR GPIOA.ODR 0000ff00 S0e483de54bb5 _
//= GPIOB.ODR GPIOB.ODR 0000ff01 S0e483de54bb5 _
//= GPIOC.ODR GPIOC.ODR 0000ff02 S0e483de54bb5 _
//= GPIOD.ODR GPIOD.ODR 0000ff03 S0e483de54bb5 _
//= GPIO.7SEG GPIO.7SEG 0000ff00 S0e483de54bb5 _
//= GPIO.LED GPIO.LED 0000ff01 S0e483de54bb5 _
//= GPIO.PORTI GPIO.PORTI 0000ff20 S0e483de54bb5 _
//= GPIO.PORTJ GPIO.PORTJ 0000ff10 S0e483de54bb5 _
//= GPIOI.IDR GPIOI.IDR 0000ff20 S0e483de54bb5 _
//= GPIOJ.IDR GPIOJ.IDR 0000ff10 S0e483de54bb5 _
//= GPIO.BTN GPIO.BTN 0000ff20 S0e483de54bb5 _
//= GPIO.SW GPIO.SW 0000ff10 S0e483de54bb5 _
//= UART.DR UART.DR 0000ff40 S33927ab86900 _
//= UART.CTRL UART.CTRL 0000ff41 S33927ab86900 _
//= UART.RSTAT UART.RSTAT 0000ff42 S33927ab86900 _
//= UART.TSTAT UART.TSTAT 0000ff43 S33927ab86900 _
//= UART.CPB UART.CPB 0000ff44 S33927ab86900 _
//= UART.SREG0 UART.SREG0 0000ff4c S33927ab86900 _
//= UART.SREG1 UART.SREG1 0000ff4d S33927ab86900 _
//= UART.SREG2 UART.SREG2 0000ff4e S33927ab86900 _
//= UART.SREG3 UART.SREG3 0000ff4f S33927ab86900 _
//L _char_is_true _char_is_true 00000068 S602f0726a14b _
//L _char_is_false _char_is_false 0000006a S602f0726a14b _
//L isdigit isdigit 0000006c S847a5c4e618b _
//L islower islower 00000071 S9a7f1c151839 _
//L isupper isupper 00000076 S154e11ca77b1 _
//L isalpha isalpha 0000007b Sf1f3b6b1f10a _
//L isalnum isalnum 00000080 Sb95a2b17779b _
//L putchar putchar 00000085 S503b4c87a8c4 _
//L eprints eprints 00000086 S23554af9f140 _
//L eprintf eprintf 00000087 Sb401aee44acb _
//L input_avail input_avail 00000088 Sedd6b6695436 _
//L read read 00000089 S84a19e8ae015 _
//= _pm_callin _pm_callin 0000f000 Sd14c348df59b _
//= _pm_enter_by_uart _pm_enter_by_uart 0000f001 Sd14c348df59b _
//= _pm_getchar _pm_getchar 0000f002 Sd14c348df59b _
//= _pm_version _pm_version 0000f003 Sd14c348df59b _
//= _pm_itobcd _pm_itobcd 0000f004 Sd14c348df59b _
//= _pm_cold_start _pm_cold_start 0000f005 Sd14c348df59b _
//= _pm_strchr _pm_strchr 0000f006 Sd14c348df59b _
//= _pm_streq _pm_streq 0000f007 Sd14c348df59b _
//= _pm_check_uart _pm_check_uart 0000f008 Sd14c348df59b _
//= _pm_input_avail _pm_input_avail 0000f008 Sd14c348df59b _
//= _pm_hexchar2value _pm_hexchar2value 0000f009 Sd14c348df59b _
//= _pm_value2hexchar _pm_value2hexchar 0000f00a Sd14c348df59b _
//= _pm_htoi _pm_htoi 0000f00b Sd14c348df59b _
//= _pm_strieq _pm_strieq 0000f00c Sd14c348df59b _
//= _pm_read _pm_read 0000f00d Sd14c348df59b _
//= _pm_putchar _pm_putchar 0000f00e Sd14c348df59b _
//= _pm_prints _pm_prints 0000f00f Sd14c348df59b _
//= _pm_printsnl _pm_printsnl 0000f010 Sd14c348df59b _
//= _pm_print_vhex _pm_print_vhex 0000f011 Sd14c348df59b _
//= _pm_pes _pm_pes 0000f012 Sd14c348df59b _
//= _pm_printd _pm_printd 0000f013 Sd14c348df59b _
//= _pm_printf _pm_printf 0000f014 Sd14c348df59b _
//= _pm_pesf _pm_pesf 0000f015 Sd14c348df59b _
//= _pm_ascii2seg _pm_ascii2seg 0000f016 Sd14c348df59b _
//L monitor monitor 0000008b Sd14c348df59b _
//L monitor_by_uart monitor_by_uart 0000008c Sd14c348df59b _
//L monitor_by_button monitor_by_button 0000008d Sd14c348df59b _
//L monitor_version monitor_version 00000093 Sd14c348df59b _
//L _nr_to_mask _nr_to_mask 00000099 S45ec84dfaab0 _
//L S45ec84dfaab0nr_to_mask_cyc nr_to_mask_cyc 0000009c s S45ec84dfaab0
//L S45ec84dfaab0nr_to_mask_ret nr_to_mask_ret 000000a1 s S45ec84dfaab0
//L S38738b71c88clast_btn last_btn 000000a4 s S38738b71c88c
//L S38738b71c88clast_sw last_sw 000000a5 s S38738b71c88c
//L S38738b71c88clast_btn_down last_btn_down 000000a6 s S38738b71c88c
//L S38738b71c88clast_sw_down last_sw_down 000000a7 s S38738b71c88c
//L S38738b71c88clast_btn_inited last_btn_inited 000000a8 s S38738b71c88c
//L S38738b71c88clast_sw_inited last_sw_inited 000000a9 s S38738b71c88c
//L _lib_edge_detect _lib_edge_detect 000000aa S38738b71c88c _
//L S38738b71c88cinit_btn init_btn 000000b2 s S38738b71c88c
//L S38738b71c88cinit_sw init_sw 000000bb s S38738b71c88c
//L S38738b71c88cpressed_inited pressed_inited 000000c4 s S38738b71c88c
//L S38738b71c88cch_btn ch_btn 000000c7 s S38738b71c88c
//L S38738b71c88cch_sw ch_sw 000000ca s S38738b71c88c
//L S38738b71c88ccheck_push check_push 000000da s S38738b71c88c
//L S38738b71c88ccheck_release check_release 000000dd s S38738b71c88c
//L S38738b71c88cpressed_true pressed_true 000000df s S38738b71c88c
//L S38738b71c88cpressed_false pressed_false 000000e1 s S38738b71c88c
//L S38738b71c88cpressed_end pressed_end 000000e2 s S38738b71c88c
//L btn_restart btn_restart 000000e8 S38738b71c88c _
//L sw_restart sw_restart 000000ed S38738b71c88c _
//L btn_posedge btn_posedge 000000f2 Saed5ad4c4c92 _
//L btn_negedge btn_negedge 000000fa Saed5ad4c4c92 _
//L btn_get btn_get 00000102 Saed5ad4c4c92 _

//; CODE
//P -
//F poll.asm
0400ff20 //C 00000     9 ldl0	r0,btn		; load addresses to pointers
//R 00000 #16 btn 0000ff20
0410ff01 //C 00001    10 ldl0	r1,led
//R 00001 #16 led 0000ff01
0420001e //C 00002    11 ldl0	r2,prev
//R 00002 #16 prev 0000001e
0430001f //C 00003    12 ldl0	r3,cnt
//R 00003 #16 cnt 0000001f
0440ff00 //C 00004    13 ldl0	r4,display
//R 00004 #16 display 0000ff00
04500004 //C 00005    14 ldl0	r5,0x4		; bit mask for BTN2
04800000 //C 00006    16 ldl0	r8,0		; clear LEDs
02810000 //C 00007    17 st	r8,r1
02830000 //C 00008    18 st	r8,r3		; clear counter
01800000 //C 00009    20 ld	r8,r0		; get actual BTN values
//G init
07885300 //C 0000a    21 and	r8,r8,r5	; clear non-needed switches
02820000 //C 0000b    22 st	r8,r2		; store actual BTN2 in prev
01800000 //C 0000c    24 cycl:	ld	r8,r0		; get buttons
//G cycl
07885300 //C 0000d    25 and	r8,r8,r5	; clear buttons but BTN2
01920000 //C 0000e    26 ld	r9,r2		; load prev
07998780 //C 0000f    27 cmp	r9,r9,r8	; compare actual and prev
b4f00019 //C 00010    28 jz	nochange
//R 00010 #16 nochange 00000019
04a00000 //C 00011    30 ldl0	r10,0		; check if actual is zero
//G changed
0788a780 //C 00012    31 cmp	r8,r8,r10	; we do not care H->L
b4f00009 //C 00013    32 jz	init
//R 00013 #16 init 00000009
01810000 //C 00014    34 ld	r8,r1		; load actual LED values
//G l_h
049000ff //C 00015    35 ldl0	r9,0xff		; mask for negation
07889400 //C 00016    36 xor	r8,r8,r9	; negate all LEDs
02810000 //C 00017    37 st	r8,r1		; put new values on LEDs
04f00009 //C 00018    38 jmp	init		; go to refresh prev
//R 00018 #16 init 00000009
01930000 //C 00019    41 ld	r9,r3		; load counter variable
//G nochange
07900200 //C 0001a    42 inc	r9		; increment by 1
02930000 //C 0001b    43 st	r9,r3		; store back into variable
02940000 //C 0001c    44 st	r9,r4		; put on 7seg display too
04f0000c //C 0001d    45 jmp	cycl
//R 0001d #16 cycl 0000000c
00000000 //C 0001e    47 db	0
//G prev
00000000 //C 0001f    48 db	0
//G cnt
//F math.asm
//P S293d8fdbaa47 _lib_segment_div
0ded0000 //C 00020    15 push	lr
//G div
0d6d0000 //C 00021    16 push	r6
021b0000 //C 00022    18 sz	r1
21f20027 //C 00023    19 NZ jmp	div_dok
//R 00023 #16 div_dok 00000027
00400000 //C 00024    20 mov	r4,r0		; div by zero
01520000 //C 00025    21 mvzl	r5,0x0
01f20038 //C 00026    22 jmp	div_ret
//R 00026 #16 div_ret 00000038
01420000 //C 00027    25 mvzl	r4,0		; Q= 0
//N div_dok S293d8fdbaa47
//N div_dummy S293d8fdbaa47
01520000 //C 00028    26 mvzl	r5,0		; R= 0
01618000 //C 00029    27 mvh	r6,0x80000000	; m= 1<<31
01600000 //C 0002a    28 mvl	r6,0x80000000
026b0000 //C 0002b    30 sz	r6
//N div_cyc S293d8fdbaa47
11f20038 //C 0002c    31 Z jmp	div_ret
//R 0002c #16 div_ret 00000038
02580000 //C 0002d    32 shl	r5		; r<<= 1
000c0600 //C 0002e    33 test	r0,r6		; if (n&m)
215d0001 //C 0002f    34 NZ or	r5,1		; r|= 1
00580100 //C 00030    35 cmp	r5,r1		; if (r>=d)
41f20036 //C 00031    36 LO jmp	div_cyc_next
//R 00031 #16 div_cyc_next 00000036
00560100 //C 00032    37 sub	r5,r1		; r-= d
004d0600 //C 00033    38 or	r4,r6		; q|= m
01f20036 //C 00034    39 jmp	div_cyc_next
//R 00034 #16 div_cyc_next 00000036
01f2002b //C 00035    40 jmp	div_cyc
//R 00035 #16 div_cyc 0000002b
02690000 //C 00036    42 shr	r6		; m>>= 1
//N div_cyc_next S293d8fdbaa47
01f2002b //C 00037    43 jmp	div_cyc
//R 00037 #16 div_cyc 0000002b
0f6d0000 //C 00038    45 pop	r6
//N div_ret S293d8fdbaa47
0ffd0000 //C 00039    46 pop	pc
//P S8e7b3d203072 _lib_segment_rand
00000049 //C 0003a    58 db	2127401289
//N seed S8e7b3d203072
0600003a //C 0003b    65 st	r0,seed
//R 0003b #16 seed 0000003a
//G srand
00f00e00 //C 0003c    66 ret
0ded0000 //C 0003d    72 push	lr
//G rand
0d0d0000 //C 0003e    73 push	r0
0d2d0000 //C 0003f    74 push	r2
0700003a //C 00040    76 ld	r0,seed
//R 00040 #16 seed 0000003a
00400000 //C 00041    77 mov	r4,r0
0122000d //C 00042    78 mvzl	r2,13
02480000 //C 00043    79 c1:	shl	r4
//N c1 S8e7b3d203072
0124ffff //C 00044    80 dec	r2
21f20043 //C 00045    81 jnz	c1
//R 00045 #16 c1 00000043
000e0400 //C 00046    82 xor	r0,r4
00400000 //C 00047    83 mov	r4,r0
01220011 //C 00048    84 mvzl	r2,17
02490000 //C 00049    85 c2:	shr	r4
//N c2 S8e7b3d203072
0124ffff //C 0004a    86 dec	r2
21f20049 //C 0004b    87 jnz	c2
//R 0004b #16 c2 00000049
000e0400 //C 0004c    88 xor	r0,r4
00400000 //C 0004d    89 mov	r4,r0
01220005 //C 0004e    90 mvzl	r2,5
02480000 //C 0004f    91 c3:	shl	r4
//N c3 S8e7b3d203072
0124ffff //C 00050    92 dec	r2
21f2004f //C 00051    93 jnz	c3
//R 00051 #16 c3 0000004f
000e0400 //C 00052    94 xor	r0,r4
0600003a //C 00053    95 st	r0,seed
//R 00053 #16 seed 0000003a
00400000 //C 00054    97 mov	r4,r0
0f2d0000 //C 00055    99 pop	r2
0f0d0000 //C 00056   100 pop	r0
0ffd0000 //C 00057   101 pop	pc
//F str.asm
//P Sbe1a78b9d15e _lib_segment_str_chr
020b0000 //C 00058    94 sz	r0		; check NULL pointer
//G str_chr
120d0000 //C 00059    95 Z clc
10f00e00 //C 0005a    96 Z ret
02100000 //C 0005b    97 zeb	r1		; prepare character
0ded0000 //C 0005c    98 push	lr
0d1d0000 //C 0005d    99 push	r1
0d2d0000 //C 0005e   100 push	r2
00400000 //C 0005f   101 mov	r4,r0
00000100 //C 00060   102 mov	r0,r1
00100400 //C 00061   103 mov	r1,r4
0400f006 //C 00062   104 call	_pm_strchr
//R 00062 #24 _pm_strchr 0000f006
00400100 //C 00063   105 mov	r4,r1
00500200 //C 00064   106 mov	r5,r2
0f2d0000 //C 00065   107 pop	r2
0f1d0000 //C 00066   108 pop	r1
0ffd0000 //C 00067   109 pop	pc
//F char.asm
//P S602f0726a14b _lib_segment_character_fn
020c0000 //C 00068    22 sec
//G _char_is_true
00f00e00 //C 00069    23 ret
020d0000 //C 0006a    25 clc
//G _char_is_false
00f00e00 //C 0006b    26 ret
//P S847a5c4e618b _lib_segment_isdigit
01080030 //C 0006c    37 cmp	R0,'0'
//G isdigit
41f2006a //C 0006d    38 ULT jmp	_char_is_false
//R 0006d #16 _char_is_false 0000006a
01080039 //C 0006e    39 cmp	R0,'9'
91f2006a //C 0006f    40 UGT jmp	_char_is_false
//R 0006f #16 _char_is_false 0000006a
01f20068 //C 00070    41 jmp _char_is_true
//R 00070 #16 _char_is_true 00000068
//P S9a7f1c151839 _lib_segment_islower
01080061 //C 00071    53 cmp	r0,'a'
//G islower
41f2006a //C 00072    54 ULT jmp	_char_is_false
//R 00072 #16 _char_is_false 0000006a
0108007a //C 00073    55 cmp	r0,'z'
91f2006a //C 00074    56 UGT jmp	_char_is_false
//R 00074 #16 _char_is_false 0000006a
01f20068 //C 00075    57 jmp	_char_is_true
//R 00075 #16 _char_is_true 00000068
//P S154e11ca77b1 _lib_segment_isupper
01080041 //C 00076    69 cmp	r0,'A'
//G isupper
41f2006a //C 00077    70 ULT jmp	_char_is_false
//R 00077 #16 _char_is_false 0000006a
0108005a //C 00078    71 cmp	r0,'Z'
91f2006a //C 00079    72 UGT jmp	_char_is_false
//R 00079 #16 _char_is_false 0000006a
01f20068 //C 0007a    73 jmp	_char_is_true
//R 0007a #16 _char_is_true 00000068
//P Sf1f3b6b1f10a _lib_segment_isalpha
0ded0000 //C 0007b    85 push	lr
//G isalpha
04000071 //C 0007c    86 call	islower
//R 0007c #24 islower 00000071
3ffd0000 //C 0007d    87 C pop	pc
04000076 //C 0007e    88 call	isupper
//R 0007e #24 isupper 00000076
0ffd0000 //C 0007f    89 pop	pc
//P Sb95a2b17779b _lib_segment_isalnum
0ded0000 //C 00080   101 push	lr
//G isalnum
0400007b //C 00081   102 call	isalpha
//R 00081 #24 isalpha 0000007b
3ffd0000 //C 00082   103 C pop	pc
0400006c //C 00083   104 call	isdigit
//R 00083 #24 isdigit 0000006c
0ffd0000 //C 00084   105 pop	pc
//F inout.asm
//P S503b4c87a8c4 _lib_segment_putchar
01f2f00e //C 00085    24 jmp	_pm_putchar
//R 00085 #16 _pm_putchar 0000f00e
//G putchar
//P S23554af9f140 _lib_segment_eprints
01f2f012 //C 00086    54 jmp	_pm_pes
//R 00086 #16 _pm_pes 0000f012
//G eprints
//P Sb401aee44acb _lib_segment_eprintf
01f2f015 //C 00087    66 jmp	_pm_pesf
//R 00087 #16 _pm_pesf 0000f015
//G eprintf
//P Sedd6b6695436 _lib_segment_input_avail
01f2f008 //C 00088    72 jmp	_pm_check_uart
//R 00088 #16 _pm_check_uart 0000f008
//G input_avail
//P S84a19e8ae015 _lib_segment_read
0740ff40 //C 00089    89 ld	r4,UART.DR
//R 00089 #16 UART.DR 0000ff40
//G read
00f00e00 //C 0008a    90 ret
//F mon.asm
//P Sd14c348df59b _lib_segment_pmon
01f2f000 //C 0008b    40 jmp	_pm_callin
//R 0008b #16 _pm_callin 0000f000
//G monitor
01f2f001 //C 0008c    44 jmp	_pm_enter_by_uart
//R 0008c #16 _pm_enter_by_uart 0000f001
//G monitor_by_uart
0ded0000 //C 0008d    48 push	lr
//G monitor_by_button
040000f2 //C 0008e    49 call	btn_posedge
//R 0008e #24 btn_posedge 000000f2
4ffd0000 //C 0008f    50 NC pop	pc
0400008b //C 00090    51 call	monitor
//R 00090 #24 monitor 0000008b
040000e8 //C 00091    52 call	btn_restart
//R 00091 #24 btn_restart 000000e8
0ffd0000 //C 00092    53 pop	pc
0ded0000 //C 00093    57 push	lr
//G monitor_version
0d0d0000 //C 00094    58 push	r0
0400f003 //C 00095    59 call	_pm_version
//R 00095 #24 _pm_version 0000f003
00400000 //C 00096    60 mov	r4,r0
0f0d0000 //C 00097    61 pop	r0
0ffd0000 //C 00098    62 pop	pc
//F bsp.asm
//P S45ec84dfaab0 _lib_segment_nr_to_mask
0d1d0000 //C 00099    26 push	r1
//G _nr_to_mask
010b001f //C 0009a    27 btst	r0,0x1f		; max nr is 31
01120001 //C 0009b    28 mvzl	r1,1		; mask for nr==0
020b0000 //C 0009c    30 sz	r0		; is nr zero?
//N nr_to_mask_cyc S45ec84dfaab0
11f200a1 //C 0009d    31 jz	nr_to_mask_ret	; if yes, go out
//R 0009d #16 nr_to_mask_ret 000000a1
02180000 //C 0009e    32 shl	r1		; shift mask up
0104ffff //C 0009f    33 dec	r0		; decrement nr
01f2009c //C 000a0    34 jmp	nr_to_mask_cyc	; check for zero
//R 000a0 #16 nr_to_mask_cyc 0000009c
00000100 //C 000a1    36 mov	r0,r1		; return mask in R0
//N nr_to_mask_ret S45ec84dfaab0
0f1d0000 //C 000a2    37 pop	r1
00f00e00 //C 000a3    38 ret
//P S38738b71c88c _lib_segment_edge
00000000 //C 000a4   120 ds	1
//+ 00000001
//N last_btn S38738b71c88c
00000000 //C 000a5   122 ds	1
//+ 00000001
//N last_sw S38738b71c88c
00000000 //C 000a6   124 ds	1
//+ 00000001
//N last_btn_down S38738b71c88c
00000000 //C 000a7   126 ds	1
//+ 00000001
//N last_sw_down S38738b71c88c
00000000 //C 000a8   128 db	0
//N last_btn_inited S38738b71c88c
00000000 //C 000a9   130 db	0
//N last_sw_inited S38738b71c88c
0ded0000 //C 000aa   141 push	lr
//G _lib_edge_detect
0d1d0000 //C 000ab   142 push	r1
0d2d0000 //C 000ac   143 push	r2
0d3d0000 //C 000ad   144 push	r3
0d4d0000 //C 000ae   145 push	r4
0d5d0000 //C 000af   146 push	r5
00500100 //C 000b0   148 mov	r5,r1		; what edge to check
31f200bb //C 000b1   149 C jmp	init_sw
//R 000b1 #16 init_sw 000000bb
071000a8 //C 000b2   151 ld	r1,last_btn_inited
//R 000b2 #16 last_btn_inited 000000a8
//N init_btn S38738b71c88c
021b0000 //C 000b3   152 sz	r1
21f200c4 //C 000b4   153 jnz	pressed_inited
//R 000b4 #16 pressed_inited 000000c4
01120001 //C 000b5   154 mvzl	r1,1
061000a8 //C 000b6   155 st	r1,last_btn_inited
//R 000b6 #16 last_btn_inited 000000a8
0710ff20 //C 000b7   156 ld	r1,GPIO.BTN
//R 000b7 #16 GPIO.BTN 0000ff20
061000a4 //C 000b8   157 st	r1,last_btn
//R 000b8 #16 last_btn 000000a4
061000a6 //C 000b9   158 st	r1,last_btn_down
//R 000b9 #16 last_btn_down 000000a6
01f200e1 //C 000ba   159 jmp	pressed_false
//R 000ba #16 pressed_false 000000e1
071000a9 //C 000bb   161 ld	r1,last_sw_inited
//R 000bb #16 last_sw_inited 000000a9
//N init_sw S38738b71c88c
021b0000 //C 000bc   162 sz	r1
21f200c4 //C 000bd   163 jnz	pressed_inited
//R 000bd #16 pressed_inited 000000c4
01120001 //C 000be   164 mvzl	r1,1
061000a9 //C 000bf   165 st	r1,last_sw_inited
//R 000bf #16 last_sw_inited 000000a9
0710ff10 //C 000c0   166 ld	r1,GPIO.SW
//R 000c0 #16 GPIO.SW 0000ff10
061000a5 //C 000c1   167 st	r1,last_sw
//R 000c1 #16 last_sw 000000a5
061000a7 //C 000c2   168 st	r1,last_sw_down
//R 000c2 #16 last_sw_down 000000a7
01f200e1 //C 000c3   169 jmp	pressed_false
//R 000c3 #16 pressed_false 000000e1
4122ff20 //C 000c4   173 NC mvzl	r2,GPIO.BTN
//R 000c4 #16 GPIO.BTN 0000ff20
//N pressed_inited S38738b71c88c
3122ff10 //C 000c5   174 C mvzl	r2,GPIO.SW
//R 000c5 #16 GPIO.SW 0000ff10
31f200ca //C 000c6   175 jc	ch_sw
//R 000c6 #16 ch_sw 000000ca
025b0000 //C 000c7   177 sz	r5
//N ch_btn S38738b71c88c
111200a4 //C 000c8   178 Z mvzl	r1,last_btn
//R 000c8 #16 last_btn 000000a4
211200a6 //C 000c9   179 NZ mvzl	r1,last_btn_down
//R 000c9 #16 last_btn_down 000000a6
025b0000 //C 000ca   181 sz	r5
//N ch_sw S38738b71c88c
111200a5 //C 000cb   182 Z mvzl	r1,last_sw
//R 000cb #16 last_sw 000000a5
211200a7 //C 000cc   183 NZ mvzl	r1,last_sw_down
//R 000cc #16 last_sw_down 000000a7
0e310000 //C 000cd   187 ld	r3,r1
0e420000 //C 000ce   188 ld	r4,r2
003f0000 //C 000cf   190 and	r3,r0		; masked last
004f0000 //C 000d0   191 and	r4,r0		; masked port
00380400 //C 000d1   192 cmp	r3,r4
11f200e1 //C 000d2   193 EQ jmp	pressed_false
//R 000d2 #16 pressed_false 000000e1
02040000 //C 000d3   194 not	r0		; negated mask
0e310000 //C 000d4   195 ld	r3,r1		; original last
003f0000 //C 000d5   196 and	r3,r0		; clear checked bit
003d0400 //C 000d6   197 or	r3,r4		; or with masked port
0c310000 //C 000d7   198 st	r3,r1		; store new last value
025b0000 //C 000d8   199 sz	r5
21f200dd //C 000d9   200 jnz	check_release
//R 000d9 #16 check_release 000000dd
024b0000 //C 000da   202 sz	r4		; check new port value
//N check_push S38738b71c88c
11f200e1 //C 000db   203 jz	pressed_false
//R 000db #16 pressed_false 000000e1
21f200df //C 000dc   204 jnz	pressed_true
//R 000dc #16 pressed_true 000000df
024b0000 //C 000dd   206 sz	r4
//N check_release S38738b71c88c
21f200e1 //C 000de   207 jnz	pressed_false
//R 000de #16 pressed_false 000000e1
020c0000 //C 000df   210 sec
//N pressed_true S38738b71c88c
01f200e2 //C 000e0   211 jmp	pressed_end
//R 000e0 #16 pressed_end 000000e2
020d0000 //C 000e1   213 clc
//N pressed_false S38738b71c88c
0f5d0000 //C 000e2   215 pop	r5
//N pressed_end S38738b71c88c
0f4d0000 //C 000e3   216 pop	r4
0f3d0000 //C 000e4   217 pop	r3
0f2d0000 //C 000e5   218 pop	r2
0f1d0000 //C 000e6   219 pop	r1
0ffd0000 //C 000e7   220 pop	pc
0d1d0000 //C 000e8   225 push	r1
//G btn_restart
0710ff20 //C 000e9   226 ld	r1,GPIO.BTN
//R 000e9 #16 GPIO.BTN 0000ff20
061000a4 //C 000ea   227 st	r1,last_btn
//R 000ea #16 last_btn 000000a4
0f1d0000 //C 000eb   228 pop	r1
00f00e00 //C 000ec   229 ret
0d1d0000 //C 000ed   233 push	r1
//G sw_restart
0710ff10 //C 000ee   234 ld	r1,GPIO.SW
//R 000ee #16 GPIO.SW 0000ff10
061000a5 //C 000ef   235 st	r1,last_sw
//R 000ef #16 last_sw 000000a5
0f1d0000 //C 000f0   236 pop	r1
00f00e00 //C 000f1   237 ret
//P Saed5ad4c4c92 _lib_segment_btn
0ded0000 //C 000f2   250 push	lr
//G btn_posedge
04000099 //C 000f3   251 call	_nr_to_mask
//R 000f3 #24 _nr_to_mask 00000099
0d1d0000 //C 000f4   252 push	r1
01120000 //C 000f5   253 mvzl	r1,0
020d0000 //C 000f6   254 clc
040000aa //C 000f7   255 call	_lib_edge_detect
//R 000f7 #24 _lib_edge_detect 000000aa
0f1d0000 //C 000f8   256 pop	r1
0ffd0000 //C 000f9   257 pop	pc
0ded0000 //C 000fa   266 push	lr
//G btn_negedge
04000099 //C 000fb   267 call	_nr_to_mask
//R 000fb #24 _nr_to_mask 00000099
0d1d0000 //C 000fc   268 push	r1
01120001 //C 000fd   269 mvzl	r1,1
020d0000 //C 000fe   270 clc
040000aa //C 000ff   271 call	_lib_edge_detect
//R 000ff #24 _lib_edge_detect 000000aa
0f1d0000 //C 00100   272 pop	r1
0ffd0000 //C 00101   273 pop	pc
0ded0000 //C 00102   282 push	lr
//G btn_get
0d1d0000 //C 00103   283 push	r1
04000099 //C 00104   284 call	_nr_to_mask
//R 00104 #24 _nr_to_mask 00000099
0710ff20 //C 00105   285 ld	r1,GPIO.BTN
//R 00105 #16 GPIO.BTN 0000ff20
001f0000 //C 00106   286 and	r1,r0
120d0000 //C 00107   287 Z clc
220c0000 //C 00108   288 NZ sec
0f1d0000 //C 00109   289 pop	r1
0ffd0000 //C 0010a   290 pop	pc
//H 2ca72386
//E
